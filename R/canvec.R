#functions involving canvec

# setup and create cache directory ----

#' Get Cache Directory
#' 
#' Get the default cache directory, which is the folder rcanvec.cache
#' in the current working directory. Modify this behaviour by passing
#' a \code{cachedir} argument to \code{canvec.download()}, \code{canvec.load()}, or
#' \code{canvec.qplot()}.
#' 
#' @return A character string of the cache directory path
#' 
#' @export
canvec.cachedir <- function() {
  dirname <- file.path(getwd(), "rcanvec.cache")
  created<-suppressWarnings(dir.create(dirname))
  dirname
}

#' Create a Bounding Box
#' 
#' Convencience method to create a bounding box like that returned by \code{sp::bbox()}.
#' To generate a bounding box from lists of lat/lon values use \code{sp::bbox(cbind(lons, lats))}.
#' 
#' @param n North bounding latitude
#' @param e East bounding longitude
#' @param s South bounding latitude
#' @param w West bounding longitude
#' @return A 2x2 matrix describing a bounding box like that returned by \code{sp::bbox()}
#' @seealso sp::bbox
#' @export
makebbox <- function(n, e, s, w) {
  matrix(c(w, s, e, n), byrow=FALSE, ncol=2, dimnames=list(c("x", "y"), c("min", "max")))
}

# Functions to get file names --------

canvec.layers <- function(...) {
  data(canvec_layers, envir=environment())
  layerids <- list(...)
  filt <- match(layerids, canvec_layers$id)
  if(any(is.na(filt))) {
    stop("Could not find layer(s): ", paste(layerids[is.na(filt)], collapse=", "))
  }
  paste0(canvec_layers$filename[filt],
        canvec_layers$geometry_ext[filt])
} 

canvec.filename <- function(ntsid, ext=NULL) {
  if(length(ntsid)>=3) {
    #canvec
    out <- paste("canvec", paste(tolower(ntsid), collapse=""), "shp", sep="_")
  } else if(length(ntsid)==2) {
    #canvec+
    out <- paste("canvec", paste(toupper(ntsid), collapse=""), "shp", sep="_")
  } else {
    stop("Invalid nts passed to canvec.filename")
  }
  
  if(is.null(ext)) {
    out
  } else {
    paste0(out, ext)
  }
}

#' Get CanVec or CanVec+ data URL
#' 
#' Get CanVec or CanVec+ data URL based on the NTS Reference (as generated by
#' \code{nts()}) provided. The URL generated may or may not exist depending whether
#' or not the sheet or area is available. CanVec data is available by mapsheet
#' (e.g. 021H01; 1:50k), CanVec+ data is available by map area (e.g. 021H; 1:250k).
#' If a the \code{ntsid} provided is a 1:50k reference, a CanVec URL will be generated.
#' Otherwise, a CanVec+ url is generated.
#' 
#' @param ntsid A single NTS Reference as generated by nts().
#' @param server The server to download from (default: \url{http://ftp2.cits.rncan.gc.ca/pub})
#' @return A URL where the given data can be found.
#' 
#' @export
canvec.url <- function(ntsid, server="http://ftp2.cits.rncan.gc.ca/pub") {
  if(length(ntsid)>=3) {
    #assume canvec, available in 50k sheets
    paste(server, "canvec/50k_shp", ntsid[1], tolower(ntsid[2]), canvec.filename(ntsid, ext=".zip"), sep="/")
  } else if(length(ntsid)==2) {
    #assume canvec+, only available in 250k sheets
    paste(server, "canvec+/shp", ntsid[1], canvec.filename(ntsid, ext=".zip"), sep="/")
  } else {
    stop("Invalid nts id passed to canvec.url: ", ntsid)
  }
}

#' Download and Extract CanVec or CanVec+ Data
#' 
#' Downloads CanVec or CanVec+ data (as applicable) to \code{cachedir} and extracts the archive.
#' 
#' @param ... A list of NTS References as generated by \code{nts()}
#' @param forcedownload A boolean describing if the file should be re-downloaded,
#'        even if already present.
#' @param forceextract Force the exctraction of the archive even if the folder is already
#'        present.
#' @param extract Pass \code{extract=FALSE} to download the archive without extracting.
#' @param cachedir Pass a specific cache directory in which to download and extract the file.
#'                  Default value is that returned by \code{canvec.cachedir()}
#' 
#' @export
canvec.download <- function(..., forcedownload=FALSE, forceextract=FALSE, extract=TRUE, cachedir=NULL) {
  if(is.null(cachedir)) {
    cachedir <- canvec.cachedir()
  }
  
  ntsids <- list(...)
  if(length(ntsids)==1 && class(ntsids[[1]])=="list") {
    ntsids <- ntsids[[1]]
  }
  
  for(ntsid in ntsids) {
    #get folder path
    folderpath <- paste(cachedir, canvec.filename(ntsid), sep="/")
    zippath <- paste(cachedir, canvec.filename(ntsid, ext=".zip"), sep="/")
    skipextract <- FALSE
    if(!file.exists(zippath) || forcedownload) { #don't know how to test if it is a directory
      #download
      uri <- canvec.url(ntsid)
      cat("Downloading sheet", paste(ntsid,collapse=""), "from", uri, "\n")
      tryCatch(download.file(uri, zippath),
               error=function(err) {
                 skipextract<<-TRUE
                 unlink(zippath)
                 cat("Could not download sheet ", paste(ntsid, collapse=""), " (sheet may not exist)")
               })
    } else {
      cat("Skipping download of", paste(ntsid,collapse=""), "\n")
    }
    if((!file.exists(folderpath) || forceextract || forcedownload) && !skipextract && extract) {
      cat("Extracting to", folderpath, "\n")
      unzip(zipfile=zippath, exdir=folderpath, overwrite=TRUE)
    } else {
      cat("Skipping extraction", "\n")
    }
  }
  cat("Done\n")
}


#' Get File Prefix of a CanVec Layer
#' 
#' Find directory and file prefix for a layer id (as 
#' listed in \code{canvec_layers$id}) in the directory specified. 
#' If the layer is not available, a warning will be issued.
#' 
#' @param directory A directory where CanVec shapefiles are located.
#' @param layerid A single layer id as listed in \code{canvec_layers$id}
#' @return The file prefix of the layer, or \code{NA} if the layer does not exist
#' 
#' @export
#' 
#' 
canvec.findlayer <- function(directory, layerid) {
  wd <- directory
  layername <- canvec.layers(layerid)
  
  #try canvec+
  shapefile <- file.path(wd, paste0(layername, ".shp"))
  if(file.exists(shapefile)) {
    return(layername)
  } else {
    #try canvec
    files <- list.files(wd, pattern=paste0("*", paste0(toupper(layername), ".shp")))
    if(length(files)==1) {
      layername <- substr(files[1], 1, nchar(files[1])-4)
      return(layername)
    } else {
      warning("Layer ", layerid, " does not exist in directory ", directory)
      return(NA)
    }
  }
}

#' Load CanVec Data
#' 
#' Load layerid for NTS reference(s) that were previously downloaded to cachedir.
#' 
#' @param ntsid One or more NTS References as generated by \code{nts()}
#' @param layerid A single layer id as listed in \code{canvec_layers$id}
#' @param cachedir Pass a specific cache directory in which files have been extracted.
#'                  Default value is that returned by \code{canvec.cachedir()}
#' @return A sp::Spatial* object loaded from the given shapefile or a \code{list}
#'         of Spatial* objects if more than one directory is specified.
#' @export
canvec.load <- function(ntsid, layerid, cachedir=NULL) {
  if(is.null(cachedir)) {
    cachedir <- canvec.cachedir()
  }
  if(class(ntsid)=="list") {
    out <- list()
    for(singleid in ntsid) {
      directory = file.path(cachedir, canvec.filename(singleid))
      out[[length(out)+1]] <- canvec.loadfromdir(directory, layerid)
    }
    out
  } else {
    #check if file exists before reading
    directory = file.path(cachedir, canvec.filename(ntsid))
    canvec.loadfromdir(directory, layerid)
  }
}

#' Load CanVec Data From Directory
#' 
#' Load layerid from a directory or directories that contain(s) CanVec data.
#' 
#' @param directory A directory or directories that contain(s) CanVec or CanVec+ data.
#' @param layerid A single layer id as listed in \code{canvec_layers$id}
#' @return A sp::Spatial* object loaded from the given shapefile or a \code{list}
#'         of Spatial* objects if more than one directory is specified.
#' 
#' @export
canvec.loadfromdir <- function(directory, layerid) {
  if(length(directory) > 1) {
    out <- list()
    for(singleid in ntsid) {
      out[[length(out)+1]] <- canvec.load(directory, layerid)
    }
    out
  } else {
    layername <- canvec.findlayer(directory, layerid)
    if(is.na(layername)) return(NULL) #shapefile not found in canvec
    rgdal::readOGR(dsn=directory, layer=layername)
  }
}

#' Export CanVec Data
#' 
#' Export \code{layerids} for one or more NTS reference(s) \code{ntsid} to path \code{tofolder}, 
#' automatically renaming layers based on their layerid. Generates warnings if files
#' cannot be found.
#' 
#' @param ntsid One or more NTS References as generated by \code{nts()}
#' @param tofolder A directory to which files should be copied.
#' @param layerids One or more layer ids as listed in \code{canvec_layers$id}. Defaults to
#'                  all layers.
#' @param cachedir Pass a specific cache directory in which files have been extracted.
#'                  Default value is that returned by \code{canvec.cachedir()}
#' 
#' @export
canvec.export <- function(ntsid, tofolder, layerids=NULL, cachedir=NULL) {
  
  dir.create(tofolder)
  
  if(class(ntsid) != "list") {
    ntsid <- list(ntsid)
  }
  if(is.null(cachedir)) {
    cachedir <- canvec.cachedir()
  }
  if(is.null(layerids)) {
    data(canvec_layers, envir=environment())
    layerids <- canvec_layers$id
  }
  
  layerinfo <- list()
  filesto <- rep(NA, length(layerids)*length(ntsid))
  for(i in 1:length(ntsid)) {
    directory = file.path(cachedir, canvec.filename(ntsid[[i]]))
    for(j in 1:length(layerids)) {
      ind <- (i-1)*length(layerids)+j
      layerinfo[[ind]] <- c(directory, canvec.findlayer(directory, layerids[j]))
      filesto[ind] <- file.path(tofolder,
                                paste(paste(ntsid[[i]], collapse=""), layerids[j], sep="_"))
    }
  }
  
  extensions <- c(".cpg", ".dbf", ".prj", ".shp", ".shx")
  for(i in 1:length(layerinfo)) {
    for(ext in extensions) {
      filefrom <- file.path(layerinfo[[i]][1], paste0(layerinfo[[i]][2], ext))
      if(file.exists(filefrom)) {
        fileto <- paste0(filesto[i],ext)
        cat("Copying", filefrom, "to", fileto, "\n")
        file.copy(filefrom, fileto, overwrite=TRUE)
      } else {
        warning("File ", filefrom, " not found. not copied")
      }
    }
    
  }
  
}

#' Quickly Plot CanVec Data
#' 
#' Quickly plot one more NTS references or automatically look up references based on a bbox
#' (in the same format returned by sp::bbox())
#' @export
canvec.qplot <- function(ntsid=NULL, bbox=NULL, waterbody=TRUE, river=TRUE, contour=FALSE, building=FALSE, road=FALSE,
                         waterbody.col="lightblue", waterbody.border="lightblue", contour.col="brown",
                         contour.lwd=0.2, river.col="lightblue", river.lwd=1, road.col="black", road.lwd=0.5,
                         building.pch=".", building.col="black", plotdata=TRUE, cachedir=NULL, data=NULL, atscale=nts.SCALE50K, ...) {
  
  
  if(!is.null(bbox)) {
    if(is.null(ntsid)) {
      ntsid <- nts(bbox=bbox, atscale = atscale)
    }
    if(!exists("xlim"))
      xlim <- bbox[1,]
    if(!exists("ylim"))
      ylim <- bbox[2,]
  } else if(is.null(ntsid)) {
    stop("No arguments specified for data to plot")
  }
  
  if(is.null(cachedir)) {
    cachedir <- canvec.cachedir()
  }
  
  if(class(ntsid) != "list") {
    ntsid <- list(ntsid)
  }
  
  if(is.null(data)) {
    #download
    canvec.download(ntsid, cachedir=cachedir)
    #load data
    data <- list()
  }
  
  #does not take into account changed ntsids
  if(waterbody && is.null(data$waterbody))
    data$waterbody <- canvec.load(ntsid, "waterbody", cachedir=cachedir)
  if(building && is.null(data$building))
    data$building <- canvec.load(ntsid, "building", cachedir=cachedir)
  if(river && is.null(data$river))
    data$river <- canvec.load(ntsid, "river", cachedir=cachedir)
  if(road && is.null(data$road))
    data$road <- canvec.load(ntsid, "road", cachedir=cachedir)
  if(contour && is.null(data$contour))
    data$contour <- canvec.load(ntsid, "contour", cachedir=cachedir)
  
  if(plotdata) {
    #plot corners of mapsheet extents 
    if(class(ntsid)=="list") {
      if(length(ntsid)==0) stop("Cannot plot background for zero mapsheets")
      bbox1 <- nts.bbox(ntsid[[1]])
      for(singleid in ntsid) {
        bbox2 <- nts.bbox(singleid)
        bbox1 <- matrix(c(min(bbox1[1,1], bbox2[1,1]), min(bbox1[2,1], bbox2[2,1]),
                         max(bbox1[1,2], bbox2[1,2]), max(bbox1[2,2], bbox2[2,2])), ncol=2, byrow=FALSE)
      }
    } else {
      bbox1 = nts.bbox(ntsid)
    }
    coords <- coordinates(t(bbox1))
    spoints = SpatialPoints(coords, proj4string = CRS("+proj=longlat +ellps=GRS80 +no_defs"))
    
    #THIS DOES NOT WORK AS PREDICTED, if xlim or ylim are passed this generates an error
    if(!exists("xlim"))
      xlim <- bbox1[1,]
    if(!exists("ylim"))
      ylim <- bbox1[2,]
    plot(spoints, pch=".", xlim=xlim, ylim=ylim, ...)
    
    if(waterbody)
      for(layer in data$waterbody) plot(layer, add=TRUE, col=waterbody.col, border=waterbody.border)
    if(contour)
      for(layer in data$contour) plot(layer, add=TRUE, col=contour.col, lwd=contour.lwd)
    if(river)
      for(layer in data$river) plot(layer, add=TRUE, col=river.col, lwd=river.lwd)
    if(building)
      for(layer in data$building) plot(layer, add=TRUE, pch=building.pch, col=building.col)
    if(road)
      for(layer in data$road) plot(layer, add=TRUE, lwd=road.lwd, col=road.col)
  }
  
  invisible(data)
}
